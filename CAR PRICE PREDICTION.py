# -*- coding: utf-8 -*-
"""notebook1aac67cbdf

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/notebook1aac67cbdf-02dd14df-b40c-46da-9d0e-5220572ac896.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20240617/auto/storage/goog4_request%26X-Goog-Date%3D20240617T065908Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D60580f54c1357ae0a674813af787a671ce439c1259b06ab72415d14a5093dff116122ee3625342c16b7b14235075f29d9cb6432ede09a37019f35be6a8e2029e67e55b99821bf647105490bd3f9e93904f310747819abd37a0cba2c902e8f8f0609b95514798e7c4d970e587906b9c93b0903948329bf81516928febb7a080274fe7ab10809632ff4f8786a9691e25b253e6355686b1910c2c9c451a61de7a35d1e147ff274fc7aa60b51689cd6ec0480e57b980725b8b7c36c4c950d4d5bcafefba7a693da5d61e417368ba1ed2603564f136a85e74036e049e1caa9e4640dbfe6b08d75ae945593d66875f7f8e13e3d4779c6685b0a876bd99d285d4f64fcf
"""

import os
import sys
from tempfile import NamedTemporaryFile
from urllib.request import urlopen
from urllib.parse import unquote, urlparse
from urllib.error import HTTPError
from zipfile import ZipFile
import tarfile
import shutil

CHUNK_SIZE = 40960
DATA_SOURCE_MAPPING = 'car-price-predictionused-cars:https%3A%2F%2Fstorage.googleapis.com%2Fkaggle-data-sets%2F2491159%2F4226692%2Fbundle%2Farchive.zip%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com%252F20240617%252Fauto%252Fstorage%252Fgoog4_request%26X-Goog-Date%3D20240617T065908Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D5f3f431f4244b1e52226f2b1a548a3677b070aef0a906f116618a0b55f97ee76caf9692900de65a5c644faddb80ebd0b3dacc770d2ea2b5399a467118f589f3dad4802482c7a66849d40dfc6baf260b18310444925c8aefdd57fbedf7fef8224839e1e67f68f97f2d20b050e7670a0bb7ffa94ad0e01e28ff9f8d6cbd39d1d696d434dd211ebe0196ede0a29771d898e2187c6f73af5de35f9df35557a95a53203c1c365c04f5b27c2ddbd313419b900e98c5212e90334eb84ce511726bc763136216ba84d4044abd2db498ebfe256f9993fac91087125ffd2f08fff78eaec0edda17e4b464fd99ddcf289af70d56a65c40ac265638f1bb458c8499fb562a18d'

KAGGLE_INPUT_PATH='/kaggle/input'
KAGGLE_WORKING_PATH='/kaggle/working'
KAGGLE_SYMLINK='kaggle'

!umount /kaggle/input/ 2> /dev/null
shutil.rmtree('/kaggle/input', ignore_errors=True)
os.makedirs(KAGGLE_INPUT_PATH, 0o777, exist_ok=True)
os.makedirs(KAGGLE_WORKING_PATH, 0o777, exist_ok=True)

try:
  os.symlink(KAGGLE_INPUT_PATH, os.path.join("..", 'input'), target_is_directory=True)
except FileExistsError:
  pass
try:
  os.symlink(KAGGLE_WORKING_PATH, os.path.join("..", 'working'), target_is_directory=True)
except FileExistsError:
  pass

for data_source_mapping in DATA_SOURCE_MAPPING.split(','):
    directory, download_url_encoded = data_source_mapping.split(':')
    download_url = unquote(download_url_encoded)
    filename = urlparse(download_url).path
    destination_path = os.path.join(KAGGLE_INPUT_PATH, directory)
    try:
        with urlopen(download_url) as fileres, NamedTemporaryFile() as tfile:
            total_length = fileres.headers['content-length']
            print(f'Downloading {directory}, {total_length} bytes compressed')
            dl = 0
            data = fileres.read(CHUNK_SIZE)
            while len(data) > 0:
                dl += len(data)
                tfile.write(data)
                done = int(50 * dl / int(total_length))
                sys.stdout.write(f"\r[{'=' * done}{' ' * (50-done)}] {dl} bytes downloaded")
                sys.stdout.flush()
                data = fileres.read(CHUNK_SIZE)
            if filename.endswith('.zip'):
              with ZipFile(tfile) as zfile:
                zfile.extractall(destination_path)
            else:
              with tarfile.open(tfile.name) as tarfile:
                tarfile.extractall(destination_path)
            print(f'\nDownloaded and uncompressed: {directory}')
    except HTTPError as e:
        print(f'Failed to load (likely expired) {download_url} to path {destination_path}')
        continue
    except OSError as e:
        print(f'Failed to load {download_url} to path {destination_path}')
        continue

print('Data source import complete.')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import warnings
warnings.filterwarnings("ignore")

df = pd.read_csv('/kaggle/input/car-price-predictionused-cars/car data.csv')

df.head()

df.columns

df.shape

df.describe().style.format(precision=2).background_gradient(cmap='RdBu')

df.info()

"""Checking Missing Values"""

print('Missing Values:')
df.isnull().sum()

# Data types of columns
print(" Data types of columns:")
print(df.dtypes)

# check for duplicate values
print('Duplicate Values:')
df.duplicated().sum()

# drop duplicate values
df = df.drop_duplicates()
df.duplicated().sum()

"""Check for outliers using boxplots"""

plt.figure(figsize=(10, 6))
sns.boxplot(df['Selling_Price'],palette='pastel')
plt.title('Boxplot of Selling Price')
plt.show()

"""Correlation Heatmap"""

numerical_columns = ['Year', 'Selling_Price', 'Present_Price', 'Driven_kms', 'Owner']

numerical_df = df[numerical_columns]

correlation_matrix = numerical_df.corr()

plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Heatmap (Numerical Columns)')
plt.show()

"""**Observation**
**Strong Positive Correlation:** Selling Price and Present Price have a very strong positive correlation indicating a nearly perfect linear relationship. This makes sense as present market value likely influences selling price.

**Year's Influence:** Year seems weakly negatively correlated with Selling Price, Present Price, and Driven_Kms. Newer cars (lower Year values) tend to have higher selling prices, lower present prices, and lower driven kilometers.

**Mileage Matters:** Driven_Kms shows a weak negative correlation with Selling Price and Present Price. Cars with lower mileage (lower Driven_Kms values) tend to sell for more.

Distribution of Numeric Features
"""

numerical_features = ['Year', 'Driven_kms', 'Selling_Price', 'Present_Price']
for feature in numerical_features:
    plt.figure(figsize=(10, 6))
    sns.displot(data=df, x=feature, kde=True)
    plt.title(f'Distribution of {feature}')
    plt.show()

"""Scatter plots"""

plt.figure(figsize=(12, 8))
sns.scatterplot(x='Driven_kms', y='Selling_Price', data=df)
plt.title('Relationship between Driven_kms and Selling_Price')
plt.show()

"""The plot suggests a negative correlation between Driven_Kms and Selling_Price. Cars with higher driven kilometers tend to sell for less."""

plt.figure(figsize=(12, 8))
sns.scatterplot(x='Present_Price', y='Selling_Price', data=df)
plt.title('Relationship between Present_Price and Selling_Price')
plt.xlabel('Present Price')
plt.ylabel('Selling Price')

plt.show()

"""Observation
Price Match: The plot reveals a strong positive correlation between Present Price and Selling Price. Cars with a higher present market value tend to sell for more.

Market Influence: This suggests the present market value heavily influences the final selling price.

Count Plots of Categorical Features
"""

colors = sns.color_palette("Set2")
categorical_features = ['Fuel_Type', 'Selling_type', 'Transmission', 'Owner']
for feature in categorical_features:
    plt.figure(figsize=(10, 6))
    sns.countplot(x=feature, data=df, palette=colors)
    plt.title(f'Frequency of {feature}', fontsize=16, color='darkblue', fontweight='bold')
    plt.xlabel(f'{feature}', fontsize=14, color='navy')
    plt.ylabel('Frequency', fontsize=14, color='navy')
    plt.xticks(fontsize=12, rotation=45)
    plt.yticks(fontsize=12)
    plt.grid(axis='y', linestyle='--', alpha=0.7)
    plt.show()

df.columns

"""Top 20 Car Models by Frequency"""

n = 20
top_car_models = df['Car_Name'].value_counts().head(n)
plt.figure(figsize=(10, 6))
sns.barplot(x=top_car_models.values, y=top_car_models.index)
plt.title(f'Top {n} Car Models by Frequency')
plt.xlabel('Frequency')
plt.ylabel('Car Model')
plt.tight_layout()
plt.show()

"""Top 20 Car Models by Average Price"""

avg_prices_by_car = df.groupby('Car_Name')['Selling_Price'].mean().sort_values(ascending=False)
n = 20
top_car_models = avg_prices_by_car.head(n)
plt.figure(figsize=(10, 6))
sns.barplot(x=top_car_models.values, y=top_car_models.index,palette='winter')
plt.title(f'Top {n} Car Models by Average Price')
plt.xlabel('Average Price')
plt.ylabel('Car Model')
plt.tight_layout()
plt.show()

"""Check Features"""

print(df['Fuel_Type'].value_counts())
print(df['Selling_type'].value_counts())
print(df['Transmission'].value_counts())

"""Encode categorical features"""

df.replace({'Fuel_Type':{'Petrol':0,'Diesel':1,'CNG':2}},inplace=True)
df.replace({'Selling_type':{'Dealer':0,'Individual':1}},inplace=True)
df.replace({'Transmission':{'Manual':0,'Automatic':1}},inplace=True)

df.head()

"""**Prediction**

Define Target variable
"""

X = df.drop(['Car_Name','Selling_Price'],axis=1)
Y = df['Selling_Price']

X

Y

"""Train and Test Data"""

X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

"""Initialize the linear regression model"""

model = LinearRegression()
model.fit(X_train, y_train)

"""Evaluation of Model"""

y_pred = model.predict(X_test)
mse = mean_squared_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
print('Mean Squared Error:', mse)
print('R-squared:', r2)

"""Predictions"""

new_car = [[2022, 20000, 0, 1, 1, 0, 0]]  # Example new car data
predicted_price = model.predict(new_car)
print('Predicted Selling Price:', predicted_price[0])